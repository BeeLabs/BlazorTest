@inherits BlazorComponent
@using Bletris.Model

@if (Piece == null)
{
    <svg id="@Id"
         width="@tetris.Width"
         height="@tetris.Height"
         viewBox="0 0 @tetris.Width @tetris.Height">
        @foreach (var item in tetris.Geos)
        {
            <rect stroke-width="1" stroke="#000000" id="bletrisbox" height="32" width="32" fill="@tetris.Colour" x="@(item.x * 32)" y="@(item.y * 32)"></rect>
        }
    </svg>
}
else
{
    <svg id="@Id"
         width="@tetris.Width"
         height="@tetris.Height"
         viewBox="0 0 @tetris.Width @tetris.Height"
         style="grid-area: @Piece.Position.y / @Piece.Position.x ;"
         tabindex="-1"
         onkeypress="@KeyHandler">
        @foreach (var item in tetris.Geos)
        {
            <rect stroke-width="1" stroke="#000000" id="bletrisbox" height="32" width="32" fill="@tetris.Colour" x="@(item.x * 32)" y="@(item.y * 32)"></rect>
        }
    </svg>
    @*<img id="@Id"
        class="bletris-piece"
        src="@Url"
        style="transform:@Transform;
           grid-area: @Piece.Position.y / @Piece.Position.x ;
           height:@(Height)px;"
        tabindex="-1"
        onkeypress="@KeyHandler" />*@
}
@functions
{
  //TODO: move all this gubbins to a separate file/class and tidy up

  [Parameter] protected int Number { get; set; }
  [Parameter] protected bool IsActive { get; set; }
  [Parameter] protected Piece Piece { get; set; }
  [Parameter] protected int Delay { get; set; }
  [Parameter] protected bool IsPaused { get; set; }

  string Id;
  int Rotation;
  Task engine;
  Tetris tetris;

  protected override void OnInit()
  {
      Id = $"BL{DateTime.Now.Ticks}";

      if (Delay == 0)
          Delay = 1000;

      tetris = Tetris.FromNumber(Number, Rotation);

      if (IsActive)
          engine = Engine();
  }

  async Task Engine()
  {
      while (IsActive && Piece != null)
      {
          await Task.Delay(Delay);
          if (!IsPaused)
          {
              Piece.Position = (Piece.Position.x, Piece.Position.y + 1);
              StateHasChanged();
              if (Piece.Position.y >= 20 - tetris.GridHeight)
              {
                  Piece.Active = false;
                  IsActive = false;
              }
          }
      }
  }

  protected override async Task OnAfterRenderAsync()
  {
      if (IsActive && !IsPaused)
      {
          await BletrisInterop.SetFocus(Id);
      }
  }

  async Task<bool> KeyHandler(UIKeyboardEventArgs args)
  {
      await Task.Run(() =>
      {
          int dx = 0;
          switch (args.Key)
          {
              case "ArrowLeft":
              case "A":
              case "a":
                  if (Piece.Position.x > 1-tetris.GridX)
                      dx = -1;
                  break;
              case "ArrowRight":
              case "D":
              case "d":
                  if (Piece.Position.x <= 9 - tetris.GridWidth)
                      dx = 1;
                  break;
              case "ArrowDown":
              case "S":
              case "s":
                  Delay = 10;
                  break;
              case "ArrowUp":
              case "W":
              case "w":
                  Rotate(1);
                  break;
              default:
                  Console.WriteLine($"Key {args.Key} Code {args.Code}");
                  break;
          };
          Piece.Position = (Piece.Position.x + dx, Piece.Position.y);
      });
      return false;
  }
  void Rotate(int rotation)
  {
      if (rotation == 0) return;
      Rotation = (Rotation + 90) % 360;
      tetris = Tetris.FromNumber(Number, Rotation);
      if (Piece.Position.x + tetris.GridX < 1 )
          Piece.Position = (1, Piece.Position.y);
      if (Piece.Position.x + tetris.GridWidth > 9)
          Piece.Position = (9, Piece.Position.y);
  }

}

